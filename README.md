решение задач по курсу up-lift от Крапов Коурсес 
Мной были пройдены две секции HardML, uplift & A/B tests

Описание решаемых задач:


ab_L0: 
Напишите функцию, которая будет вычислять доверительный интервал для оценки параметра p распределения Бернулли B(p), 
используя свойство асимптотической нормальности ОМП.
При решении используйте приближение z(α/2) =1.96


ab_L1:
1)Напишите функцию для оценки ошибки первого рода.
2)Напишите функцию для оценки ошибки второго рода.
  Добавлять эффект к экспериментальной группе можно разными способами. 
  Способ добавления эффекта может повлиять на результаты статистических критериев и оценку вероятности ошибки II рода. 
  При выполнении задания считайте, что эффект распределён равномерно по всем объектам экспериментальной группы, 
  то есть метрики объектов в среднем увеличиваются на одинаковую величину.


ab_L2:
Вычисление метрик для мониторинга:
Суммарная выручка,
Количество покупок,
Средний чек,
Среднее количество товаров в покупке.
Дополнительно добавим возможность фильтровать данные по различным параметрам. 
Это может быть полезно для того, чтобы посмотреть, как меняются продажи в пилотной и контрольной группах или в какой-то отдельной категории товаров.
На вход функции будет подаваться датафрейм с данными о продажах, словарь с фильтрами и период, за который нужно посчитать метрики.
Функция должна вернуть датафрейм, в индексах которого будут все даты из указанного периода, отсортированные по возрастанию, 
а в столбцах — метрики ['revenue', 'number_purchases', 'average_check', 'average_number_items']. 
Формат данных столбцов — float, формат данных индекса — datetime64[ns].
Если в какие-то дни не было продаж, то пропуск нужно заполнить нулём.

ab_L3:
Напишите функцию, которая оценивает необходимое количество данных для нахождения определённого эффекта некоторой метрики.
На вход подаётся датафрейм со множеством значений целевой метрики, список размеров эффекта и допустимые ошибки первого и второго рода. 
На выходе должен получиться датафрейм с двумя столбцами ['effect', 'sample_size'] — ожидаемый размер эффекта и sample_size.


ab_L4:
Стратифицированный подбор групп
На вход подаются:
Датафрейм с описанием объектов, которые нужно стратифицировать;
Название параметров, по которым нужно стратифицировать:
Размер групп;
Словарь весов страт (если None, то веса нужно взять пропорционально доле страт в датафрейме);
Состояние генератора случайных чисел.

Функция должна возвращать пару датафреймов того же формата, что она получила на вход. 
Доли страт в каждом датафрейме должны в точности совпадать друг с другом и могут немного отличаться от переданных в функцию или посчитанных на основе 
входных данных, но не более чем на 2 / group_size (предполагается, что размеры страт достаточно велики, чтобы это всегда было реализуемо).
При повторном вызове функции при seed=None полученные группы должны отличаться от вернувшихся при прошлом вызове функции 
(необходимо использовать рандомизацию).


ab_L5:
Вычисление метрик для CUPED.
Наша цель — научиться получать преобразованную с помощью CUPED метрику.
Для этого нужно будет написать две функции.
Первая функция вспомогательная, она будет вычислять значения целевой метрики для пользователей на произвольном промежутке времени. 
Первую функцию можно будет использовать, чтобы посчитать значения метрики пользователей во время пилота и до пилота.
Вторая функция будет вычислять непосредственно преобразованную cuped-метрику. 
В качестве ковариаты будем использовать значение метрики, посчитанное на периоде до начала пилота.
Целевая метрика — суммарная стоимость покупок пользователя за определённый период времени.


ab_L6:
Вычисление линеаризованной метрики
Нужно написать функцию, которая считает пользовательскую линеаризованную метрику.
Допустим, у нас есть информация о покупках пользователей. 
Мы хотим оценить значимость отличия средней стоимости покупки. Это ratio-метрика, так как мы делим сумму стоимостей покупок на количество покупок.


ab_L7:
Задача 1. Распределение пользователей по экспериментам.
Напишите класс ABSplitter, который будет распределять эксперименты по слотам и определять конфигурацию пользователя 
(в каких экспериментах он участвует и в какой группе в каждом эксперименте находится — в пилотной или контрольной).

При инициализации класса задаются следующие параметры:
count_slots — количество слотов.
salt_one — соль для вычисления хеша при разбиении пользователей по слотам.
salt_two — соль для вычисления хеша для разбиения на пилотную и контрольную группы.
У класса должно быть два метода:

split_experiments — получает на вход список экспериментов и распределяет их по слотам.
process_user — получает на вход id пользователя, распределяет его в слот и присваивает ему пилотную/контрольную группу пилотов, 
которые есть в этом слоте.

Атрибуты класса:
count_slots — int, количество слотов.
salt_one, salt_two — int, соли для хеширования первого и второго уровня.
slots — массив идентификаторов слотов от 0 до count_slots - 1.
experiments — список словарей с описанием экспериментов.
experiment_to_slots — словарь {experiment_id: [slot, ...]}
slot_to_experiments — словарь {slot: [experiment_id, ...]}
Замечания:
Пользователь с одним id при фиксированном значении salt_one должен попадать в один и тот же слот. 
А при фиксированной salt_two — в одни и те же пилотные/контрольные группы для каждого пилота соответственно. 
Например, если он был в эксперименте "1" в контроле, а в эксперименте "2" в пилоте, то так должно быть каждый раз.
При изменении salt_one должно меняться распределение пользователей по слотам. 
При изменении salt_two должно меняться распределение по контрольным/пилотным группам.
При распределении пользователя на пилотную и контрольную группу (второе хеширование) необходимо хешировать [id пользователя] + [id пилота],
чтобы в разных пилотах он попадал в разные группы, а не всегда только в пилот или только в контроль.


ab_L8:
Класс для последовательного тестирования.
Нужно написать класс для последовательного тестирования гипотезы о равенстве средних для случая простой основной гипотезы и 
простой альтернативной гипотезы.

Класс должен иметь два метода:
run_test: запуск теста по всем имеющимся данным с начала пилота.
add_data: проверка теста на основании добавленных ранее данных и новых данных.

Пример:
Допустим, у нас есть высокочастотный источник данных. Данные из эксперимента поступают каждые 10 минут. 
Через час после начала эксперимента мы решили посмотреть, достаточно ли информации для принятия решения. 
Для этого мы инициализируем объект класса SequentialTester и вызываем метод run_test, куда передаём все накопленные за первый час данные. 
Данных оказалось недостаточно, нужно продолжать эксперимент. Выгружать каждый раз все данные с самого начала эксперимента может быть ресурсозатратно, 
поэтому далее будем пользоваться методом add_data. 
При каждом поступлении новых данных будем вызывать метод add_data, в который будем передавать только новые данные. 
Результат метода add_data должен быть посчитан на основании новых данных, которые ему были переданы, и всех ранее добавленных данных.


uplift_tree : 
В этом задании предлагается собственными руками написать алгоритм построения uplift-дерева. 
Нужно будет реализовать uplift-дерево с критерием разбиения DeltaDeltaP


uplift_project_hw: 
В этом задании вы попробуете написать расчет новых признаков так, словно вы делаете это в проекте с устоявшимся форматом подобных скриптов. 
Нужно будет написать модуль с реализацией несколько групп признаков (“FeatureCalcer” в терминологии лекции) и преобразований.


uplift_prolect_fin: 
Сеть магазинов "Хитрый лис" занимается исключительно продажей фисштеха (пряности) в ряде городов (Новиград, Оксенфурт и прочие). 
Полгода назад "Хитрый лис" провел маркетинговую кампанию. 
Части клиентов с воронами разослали письма с персональным предложением - "Успейте получить скидку в 40 оренов при первой покупке от одного грамма фисштеха.
Скидка действует неделю". Причем бывший маркетолог "Хитрого лиса" недолго думал и выбрал аудиторию для коммуникации случайным образом. 
Перед Вами стоит задача выбрать часть клиентов "Хитрого лиса" так, чтобы суммарная прибыль (определение в разделе оценки) от кампании с подобным 
предложением была как можно больше. Решением будет список отобранных клиентов. 
Контрольную группу выделять не нужно - необходимые процедуры для оценки решения будут проделаны в системе. 
В вашем распоряжении информация о продажах за последние 250 дней, базовая информация о покупателях, история запущенных кампаний. 
Важно знать: Цена 1 г фисштеха равна 80 оренам. 
Себестоимость равна 52 оренам Отправка одного сообщения вороном стоит 1 орен У "Хитрого лиса" есть конкурент 😉 - сеть таверн "Семь котов",
в которых тоже продают фисштех

